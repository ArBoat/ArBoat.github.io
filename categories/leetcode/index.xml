<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeetCode on ArBlog</title>
    <link>https://blog.arboat.top/categories/leetcode/</link>
    <description>Recent content in LeetCode on ArBlog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 21 Jul 2020 00:05:00 +0800</lastBuildDate>
    
	<atom:link href="https://blog.arboat.top/categories/leetcode/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>206.Reverse Linked List</title>
      <link>https://blog.arboat.top/posts/leetcode-206.reverse-linked-list/</link>
      <pubDate>Tue, 21 Jul 2020 00:05:00 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-206.reverse-linked-list/</guid>
      <description>/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */  iteratively  时间复杂度：O(n)，假设 n 是列表的长度，时间复杂度是 O(n)。 空间复杂度：O(1)。  Go:
func reverseList(head *ListNode) *ListNode { var pre *ListNode for head != nil { head, pre, head.Next = head.Next, head, pre } // for head != nil { // temp:=head.Next // head.Next = pre // pre = head // head = temp //} return pre }  Pyhton:</description>
    </item>
    
    <item>
      <title>24.Swap Nodes in Pairs</title>
      <link>https://blog.arboat.top/posts/leetcode-24.swap-nodes-in-pairs/</link>
      <pubDate>Tue, 21 Jul 2020 00:05:00 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-24.swap-nodes-in-pairs/</guid>
      <description>/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */  iteratively  时间复杂度：O(n)，假设 n 是列表的长度，时间复杂度是 O(n)。 空间复杂度：O(1)。  Go:
func swapPairs(head *ListNode) *ListNode { guard:=&amp;amp;ListNode{Next:head} temp:=guard for temp.Next != nil &amp;amp;&amp;amp; temp.Next.Next != nil { first := temp.Next second := temp.Next.Next temp.Next = second first.Next = second.Next second.Next = first temp = first // 已经交换为第二个 } return guard.Next }  Pyhton:</description>
    </item>
    
    <item>
      <title>25.Reverse Nodes in k-Group</title>
      <link>https://blog.arboat.top/posts/leetcode-25.reverse-nodes-in-k-group/</link>
      <pubDate>Tue, 21 Jul 2020 00:05:00 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-25.reverse-nodes-in-k-group/</guid>
      <description>/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */  recursively  时间复杂度为 O(n*K)最好的情况为 O(n) 最差的情况未 O(n^2) 空间复杂度：O(1)，除了几个必须的节点指针外，并没有占用其他空间  Go:
 func reverseKGroup(head *ListNode, k int) *ListNode { dummy:= &amp;amp;ListNode{Next:head} //point 1 pre:=dummy //point 2 for head != nil { tail:=pre //point 3 for i:=0;i&amp;lt;k;i++{ tail = tail.Next if tail == nil { return dummy.Next } } temp:=tail.Next head, tail = reverse(head,tail) pre.</description>
    </item>
    
    <item>
      <title>102.Binary Tree Level Order Traversal</title>
      <link>https://blog.arboat.top/posts/leetcode-102.binary-tree-level-order-traversal/</link>
      <pubDate>Tue, 21 Jul 2020 00:00:04 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-102.binary-tree-level-order-traversal/</guid>
      <description>recursively  时间复杂度:O(n) 空间复杂度:O(logn)  Go:
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ 少赋值内存占用少 var res = make([]int, 0) // leetcode 多个测试用例的时候要重置为零值 func postorderTraversal(root *TreeNode) []int { res=make([]int,0) postoder(root) return res } func postoder(root *TreeNode) { if root != nil { postoder(root.Left) postoder(root.Right) res=append(res,root.Val) } } // 两次append func postorderTraversal(root *TreeNode) []int { if root == nil { return []int{} } res := append(postorderTraversal(root.</description>
    </item>
    
    <item>
      <title>104.Maximum Depth of Binary Tree</title>
      <link>https://blog.arboat.top/posts/leetcode-104.maximum-depth-of-binary-tree/</link>
      <pubDate>Tue, 21 Jul 2020 00:00:04 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-104.maximum-depth-of-binary-tree/</guid>
      <description>recursively  时间复杂度:O(n) 空间复杂度:O(height) 树的高度  Go:
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func maxDepth(root *TreeNode) int { if root == nil { return 0 } return max(maxDepth(root.Left),maxDepth(root.Right)) + 1 } func max(a,b int) int { if a &amp;gt; b { return a } return b } </description>
    </item>
    
    <item>
      <title>105.Construct Binary Tree from Preorder and Inorder Traversal</title>
      <link>https://blog.arboat.top/posts/leetcode-105.construct-binary-tree-from-preorder-and-inorder-traversal/</link>
      <pubDate>Tue, 21 Jul 2020 00:00:04 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-105.construct-binary-tree-from-preorder-and-inorder-traversal/</guid>
      <description>recursively  时间复杂度:O(n) 空间复杂度:O(n)  Go:
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { for root!=nil { switch { case p.Val &amp;gt; root.Val &amp;amp;&amp;amp; q.Val &amp;gt; root.Val: root = root.Right case p.Val &amp;lt; root.Val &amp;amp;&amp;amp; q.Val &amp;lt; root.Val: root = root.Left default: return root } } return nil } </description>
    </item>
    
    <item>
      <title>111.Minimum Depth of Binary Tree</title>
      <link>https://blog.arboat.top/posts/leetcode-111.minimum-depth-of-binary-tree/</link>
      <pubDate>Tue, 21 Jul 2020 00:00:04 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-111.minimum-depth-of-binary-tree/</guid>
      <description>recursively  时间复杂度:O(n) 空间复杂度:O(n)  Go:
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func minDepth(root *TreeNode) int { if root == nil { return 0 } l := minDepth(root.Left) r := minDepth(root.Right) // 只有一个叶子节点 要返回另一边 if root.Left == nil { return r+1 } if root.Right == nil { return l+1 } return min(l, r) + 1 } func min(a, b int) int { if a &amp;lt; b { return a } return b } </description>
    </item>
    
    <item>
      <title>144.Binary Tree Preorder Traversal</title>
      <link>https://blog.arboat.top/posts/leetcode-144.binary-tree-preorder-traversal/</link>
      <pubDate>Tue, 21 Jul 2020 00:00:04 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-144.binary-tree-preorder-traversal/</guid>
      <description>recursively  时间复杂度:O(n) 空间复杂度:O(logn)  Go:
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ 少赋值内存占用少 var res = make([]int, 0) // leetcode 多个测试用例的时候要重置为零值 func preorderTraversal(root *TreeNode) []int { res = make([]int,0) preorder(root) return res } func preorder(root *TreeNode){ if root != nil { res = append(res,root.Val) preorder(root.Left) preorder(root.Right) } } // 两次append func preorderTraversal(root *TreeNode) []int { if root == nil { return []int{} } res := append([]int{root.</description>
    </item>
    
    <item>
      <title>145.Binary Tree Postorder Traversal</title>
      <link>https://blog.arboat.top/posts/leetcode-145.binary-tree-postorder-traversal/</link>
      <pubDate>Tue, 21 Jul 2020 00:00:04 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-145.binary-tree-postorder-traversal/</guid>
      <description>recursively  时间复杂度:O(n) 空间复杂度:O(logn)  Go:
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ 少赋值内存占用少 var res = make([]int, 0) // leetcode 多个测试用例的时候要重置为零值 func postorderTraversal(root *TreeNode) []int { res=make([]int,0) postoder(root) return res } func postoder(root *TreeNode) { if root != nil { postoder(root.Left) postoder(root.Right) res=append(res,root.Val) } } // 两次append func postorderTraversal(root *TreeNode) []int { if root == nil { return []int{} } res := append(postorderTraversal(root.</description>
    </item>
    
    <item>
      <title>21. Merge Two Sorted Lists</title>
      <link>https://blog.arboat.top/posts/leetcode-21.merge-two-sorted-lists/</link>
      <pubDate>Tue, 21 Jul 2020 00:00:04 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-21.merge-two-sorted-lists/</guid>
      <description>递归 recursion  时间复杂度：O(n+m) 空间复杂度：O(n+m)  Go:
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { if l1 == nil { return l2 } else if l2 == nil { return l1 } else if l1.Val &amp;lt; l2.Val { l1.Next = mergeTwoLists(l1.Next,l2) return l1 } else { l2.Next = mergeTwoLists(l1,l2.Next) return l2 } }  Python:</description>
    </item>
    
    <item>
      <title>22.Generate Parentheses</title>
      <link>https://blog.arboat.top/posts/leetcode-22.generate-parentheses/</link>
      <pubDate>Tue, 21 Jul 2020 00:00:04 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-22.generate-parentheses/</guid>
      <description>递归 recursion  时间复杂度：O(2^n) 空间复杂度：O(n)  Go:
var res []string func generateParenthesis(n int) []string { res = make([]string,0) genetate(0,0,n,&amp;quot;&amp;quot;) return res } func genetate(left,right, max int, s string){ if left == max &amp;amp;&amp;amp; right == max { res = append(res,s) return } if left &amp;lt; max { genetate(left+1, right, max, s+&amp;quot;(&amp;quot;) } if right &amp;lt; left { genetate(left, right+1, max, s+&amp;quot;)&amp;quot;) } }  </description>
    </item>
    
    <item>
      <title>226.Invert Binary Tree</title>
      <link>https://blog.arboat.top/posts/leetcode-226.invert-binary-tree/</link>
      <pubDate>Tue, 21 Jul 2020 00:00:04 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-226.invert-binary-tree/</guid>
      <description>递归 recursion  时间复杂度：O(n) 空间复杂度：O(n)  Go:
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func invertTree(root *TreeNode) *TreeNode { if root == nil { return nil } l:=invertTree(root.Left) r:=invertTree(root.Right) root.Left = r root.Right = l return root } </description>
    </item>
    
    <item>
      <title>235.Lowest Common Ancestor of a Binary Search Tree</title>
      <link>https://blog.arboat.top/posts/leetcode-235.lowest-common-ancestor-of-a-binary-search-tree/</link>
      <pubDate>Tue, 21 Jul 2020 00:00:04 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-235.lowest-common-ancestor-of-a-binary-search-tree/</guid>
      <description>recursively  时间复杂度:O(n) 空间复杂度:O(n)  Go:
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { for root!=nil { switch { case p.Val &amp;gt; root.Val &amp;amp;&amp;amp; q.Val &amp;gt; root.Val: root = root.Right case p.Val &amp;lt; root.Val &amp;amp;&amp;amp; q.Val &amp;lt; root.Val: root = root.Left default: return root } } return nil } </description>
    </item>
    
    <item>
      <title>235.Lowest Common Ancestor of a Binary Tree</title>
      <link>https://blog.arboat.top/posts/leetcode-236.lowest-common-ancestor-of-a-binary-tree-copy/</link>
      <pubDate>Tue, 21 Jul 2020 00:00:04 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-236.lowest-common-ancestor-of-a-binary-tree-copy/</guid>
      <description>recursively  时间复杂度:O(n) 空间复杂度:O(n)  Go:
/** * Definition for TreeNode. * type TreeNode struct { * Val int * Left *ListNode * Right *ListNode * } */ func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil { return nil } if root.Val == p.Val || root.Val == q.Val { return root } left := lowestCommonAncestor(root.Left, p, q) right := lowestCommonAncestor(root.Right, p, q) if left != nil &amp;amp;&amp;amp; right !</description>
    </item>
    
    <item>
      <title>297.Serialize and Deserialize Binary Tree</title>
      <link>https://blog.arboat.top/posts/leetcode-297.serialize-and-deserialize-binary-tree/</link>
      <pubDate>Tue, 21 Jul 2020 00:00:04 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-297.serialize-and-deserialize-binary-tree/</guid>
      <description>recursively  时间复杂度:O(n) 空间复杂度:O(n)  Go:
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ type Codec struct { res []string } func Constructor() Codec { return Codec{} } // Serializes a tree to a single string. func (this *Codec) serialize(root *TreeNode) string { if root == nil { return &amp;quot;#&amp;quot; } return strconv.Itoa(root.Val) + &amp;quot;,&amp;quot; + this.</description>
    </item>
    
    <item>
      <title>559.Maximum Depth of N-ary Tree</title>
      <link>https://blog.arboat.top/posts/leetcode-559.maximum-depth-of-n-ary-tree/</link>
      <pubDate>Tue, 21 Jul 2020 00:00:04 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-559.maximum-depth-of-n-ary-tree/</guid>
      <description>recursively  时间复杂度:O(n) 空间复杂度：最坏情况下, 树完全非平衡， 例如 每个节点有且仅有一个孩子节点，递归调用会发生 N 次（等于树的深度），所以存储调用栈需要 O(N)。 但是在最好情况下（树完全平衡），树的高度为 log(N)。 所以在此情况下空间复杂度为 O(log(N))  Go:
/** * Definition for a Node. * type Node struct { * Val int * Children []*Node * } */ func maxDepth(root *Node) int { if root == nil { return 0 } res:=0 for _,v:=range root.Children { res = max(res,maxDepth(v)) } return res + 1 } func max(a,b int) int { if a&amp;gt;b { return a } return b } </description>
    </item>
    
    <item>
      <title>589.N-ary Tree Preorder Traversal</title>
      <link>https://blog.arboat.top/posts/leetcode-589.n-ary-tree-preorder-traversal/</link>
      <pubDate>Tue, 21 Jul 2020 00:00:04 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-589.n-ary-tree-preorder-traversal/</guid>
      <description>recursively  时间复杂度:O(n) 空间复杂度:平均O(logn), 最坏O(n)  Go:
/** * Definition for a Node. * type Node struct { * Val int * Children []*Node * } */ var res []int func preorder(root *Node) []int { res = []int{} dfs(root) return res } func dfs(root *Node){ if root != nil { res = append(res,root.Val) for _,v:=range root.Children { dfs(v) } } }  iteratively  时间复杂度:O(n) 空间复杂度:O(n)  Go:
func preorder(root *Node) []int { var res []int var stack []*Node for len(stack)&amp;gt;0 || root !</description>
    </item>
    
    <item>
      <title>590.N-ary Tree Postorder Traversal</title>
      <link>https://blog.arboat.top/posts/leetcode-590.n-ary-tree-postorder-traversal/</link>
      <pubDate>Tue, 21 Jul 2020 00:00:04 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-590.n-ary-tree-postorder-traversal/</guid>
      <description>recursively  时间复杂度:O(n) 空间复杂度:O(logn)  Go:
/** * Definition for a Node. * type Node struct { * Val int * Children []*Node * } */ var res []int func postorder(root *Node) []int { res = []int{} dfs(root) return res } func dfs(root *Node){ if root!=nil { for _,v:=range root.Children { dfs(v) } res = append(res,root.Val) } }  iteratively  时间复杂度:O(n) 空间复杂度:O(n)  Go:
func postorder(root *Node) []int { res:=[]int{} var stack []*Node for len(stack)&amp;gt;0 || root !</description>
    </item>
    
    <item>
      <title>92.Reverse Linked List II (part)</title>
      <link>https://blog.arboat.top/posts/leetcode-92.reverse-linked-list-ii-part/</link>
      <pubDate>Tue, 21 Jul 2020 00:00:04 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-92.reverse-linked-list-ii-part/</guid>
      <description>recursively 反转链表前 N 个节点  func reverseList(head *ListNode, n int) *ListNode { var successor *ListNode if n == 1 { successor = head.next return head } pre:=reverseList(head.Next,n-1) head.Next.Next = head head.Next = successor return pre } 时间复杂度：O(n)，假设 n 是列表的长度，那么时间复杂度为 O(n)。 空间复杂度：O(n)，由于使用递归，将会使用隐式栈空间。递归深度可能会达到 n 层。  Reverse a linked list from position m to n /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseBetween(head *ListNode, m int, n int) *ListNode { if m == 1 { return reverseN(head, n) } head.</description>
    </item>
    
    <item>
      <title>94.Binary Tree Inorder Traversal</title>
      <link>https://blog.arboat.top/posts/leetcode-94.binary-tree-inorder-traversal/</link>
      <pubDate>Tue, 21 Jul 2020 00:00:04 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-94.binary-tree-inorder-traversal/</guid>
      <description>recursively  时间复杂度:O(n) 空间复杂度:O(logn)  Go:
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func inorderTraversal(root *TreeNode) []int { var res []int var stack []*TreeNode for len(stack)&amp;gt;0 || root != nil { // 为了第一次判断nil for root != nil { stack = append(stack, root) root = root.Left } res = append(res,stack[len(stack)-1].Val) root = stack[len(stack)-1].Right stack = stack[:len(stack)-1] } return res }  </description>
    </item>
    
    <item>
      <title>98.Validate Binary Search Tree</title>
      <link>https://blog.arboat.top/posts/leetcode-98.validate-binary-search-tree/</link>
      <pubDate>Tue, 21 Jul 2020 00:00:04 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-98.validate-binary-search-tree/</guid>
      <description>递归 recursion  时间复杂度：O(n) 空间复杂度：O(n)  Go:
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func isValidBST(root *TreeNode) bool { return validate(root,math.MinInt64, math.MaxInt64) } func validate(root *TreeNode, l, r int) bool { if root == nil { return true } if root.Val &amp;lt;= l || root.Val &amp;gt;= r { return false } return validate(root.</description>
    </item>
    
    <item>
      <title>20.Valid Parentheses</title>
      <link>https://blog.arboat.top/posts/leetcode-20.valid-parentheses/</link>
      <pubDate>Mon, 01 Jun 2020 00:00:06 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-20.valid-parentheses/</guid>
      <description>时间复杂度:O(n) 空间复杂度:O(n)  stack Go:
func isValid(s string) bool { if s == &amp;quot;&amp;quot;{ return true } if len(s)%2!=0 { return false } m:= map[rune]rune{&#39;)&#39;:&#39;(&#39;,&#39;]&#39;:&#39;[&#39;,&#39;}&#39;:&#39;{&#39;} 单引号表示rune,注意用右括号作为key stack:=make([]rune,0) for _,v:=range s{ switch v { case &#39;(&#39;,&#39;[&#39;,&#39;{&#39;: stack = append(stack,v) case &#39;)&#39;,&#39;]&#39;,&#39;}&#39;: if len(stack)==0 || stack[len(stack)-1] != m[v] { return false } stack = stack[:len(stack)-1] } } return len(stack)==0 }  Python:
class Solution: def isValid(self, s: str) -&amp;gt; bool: if s==&amp;quot;&amp;quot;: return True if len(s)%2!</description>
    </item>
    
    <item>
      <title>141.Linked List Cycle</title>
      <link>https://blog.arboat.top/posts/leetcode-141.linked-list-cycle/</link>
      <pubDate>Thu, 21 May 2020 00:05:00 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-141.linked-list-cycle/</guid>
      <description>快慢指针  时间复杂度： O(n) 空间复杂度：O(1)  Go:
func hasCycle(head *ListNode) bool { if head == nil || head.Next == nil { return false } slow:=head fast:=head.Next for slow != fast { if fast ==nil || fast.Next == nil { return false } slow=slow.Next fast=fast.Next.Next } return true }  Python:
class Solution: def hasCycle(self, head: ListNode) -&amp;gt; bool: if head == None or head.next == None: return False slow, fast = head,head.</description>
    </item>
    
    <item>
      <title>155.Min Stack</title>
      <link>https://blog.arboat.top/posts/leetcode-155.min-stack/</link>
      <pubDate>Thu, 21 May 2020 00:05:00 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-155.min-stack/</guid>
      <description>问清空栈操作  辅助栈 注意相等时也压入辅助栈  时间复杂度:O(n) 空间复杂度:O(1)  Go:
type MinStack struct { stack []int min []int } /** initialize your data structure here. */ func Constructor() MinStack { return MinStack{} } func (this *MinStack) Push(x int) { this.stack = append(this.stack,x) if len(this.min)==0{ this.min = append(this.min,x) } else { if this.min[len(this.min)-1]&amp;gt;=x { // 等于很重要 this.min = append(this.min,x) } } } func (this *MinStack) Pop() { if this.stack[len(this.stack)-1] == this.min[len(this.min)-1]{ this.</description>
    </item>
    
    <item>
      <title>239.Sliding Window Maximum</title>
      <link>https://blog.arboat.top/posts/leetcode-239.sliding-window-maximum/</link>
      <pubDate>Thu, 21 May 2020 00:05:00 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-239.sliding-window-maximum/</guid>
      <description>暴力法 有 n-k+1个滑动窗口
 时间复杂度 O(nk) 空间复杂度 O(n-k+1)  deque  时间复杂度 O(n) 空间复杂度 O(n)  Go:
func maxSlidingWindow(nums []int, k int) []int { if nums == nil { return []int{} } //window 是一个维护当前最大值下表的deque window, res:= make([]int,0), make([]int,0) for i,v:= range nums { // 保证window长度，从左弹 if i&amp;gt;=k &amp;amp;&amp;amp; window[0]&amp;lt;= i-k { window = window[1:] } // 保证window[0]存最大，从右弹 for len(window)&amp;gt;0 &amp;amp;&amp;amp; nums[window[len(window)-1]] &amp;lt;= v{ window = window[:len(window)-1] } window = append(window,i) 第一个窗口 if i &amp;gt;= k-1 { res = append(res, nums[window[0]]) } } return res } </description>
    </item>
    
    <item>
      <title>42.Trapping Rain Water</title>
      <link>https://blog.arboat.top/posts/leetcode-42.trapping-rain-water/</link>
      <pubDate>Thu, 21 May 2020 00:05:00 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-42.trapping-rain-water/</guid>
      <description>暴力法  时间复杂度 O(n^2) 空间复杂度 O(1)  遍历所有高度， 以高度求最大矩形
单调栈 递减  时间复杂度 O(n) 空间复杂度 O(n)  Go:
func trap(height []int) int { res:=0 q:=make([]int,0) for i:=0;i&amp;lt;len(height);i++{ for len(q)&amp;gt;0 &amp;amp;&amp;amp; height[q[len(q)-1]]&amp;lt;height[i]{ temp:=height[q[len(q)-1]] q=q[:len(q)-1] if len(q)&amp;gt;0{ h:= min(height[q[len(q)-1]],height[i])-temp w:= i - q[len(q)-1] - 1 res+=h*w } } q=append(q,i) } return res } func min(x,y int) int { if x&amp;lt;y { return x } return y }  双指针 Go:
func trap(height []int) int { left,right:=0,len(height)-1 leftmax,rightmax:=0,0 res:=0 for left&amp;lt;=right{ if leftmax&amp;lt;rightmax{ if height[left]&amp;gt;leftmax{ leftmax = height[left] } else { res += leftmax - height[left] } left++ } else { if height[right]&amp;gt; rightmax { rightmax = height[right] } else { res+= rightmax - height[right] } right-- } } return res } </description>
    </item>
    
    <item>
      <title>641.Design Circular Deque</title>
      <link>https://blog.arboat.top/posts/leetcode-641.design-circular-deque/</link>
      <pubDate>Thu, 21 May 2020 00:05:00 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-641.design-circular-deque/</guid>
      <description>front指针指向第一个，rear指针指向最后一个下一位 Go:
type MyCircularDeque struct { data []int //data容量为实际长度+1 front int //指向队列头部第 1 个有效数据的位置 rear int //指向队列尾部（即最后 1 个有效数据）的下一个位置，即下一个从队尾入队元素的位置。 } /** Initialize your data structure here. Set the size of the deque to be k. */ func Constructor(k int) MyCircularDeque { return MyCircularDeque { data: make([]int,k+1,k+1), //rear指向下一个位置所谓data+1 front:0, rear:0, } } /** Adds an item at the front of Deque. Return true if the operation is successful. */ func (this *MyCircularDeque) InsertFront(value int) bool { if this.</description>
    </item>
    
    <item>
      <title>84.Largest Rectangle in Histogram</title>
      <link>https://blog.arboat.top/posts/leetcode-142.linked-list-cycle-ii/</link>
      <pubDate>Thu, 21 May 2020 00:05:00 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-142.linked-list-cycle-ii/</guid>
      <description>快慢指针 2(F+a)=F+a+b+a -&amp;gt; F=b
 时间复杂度： O(n) 空间复杂度：O(1)  Go:
func detectCycle(head *ListNode) *ListNode { slow,fast:=head,head for { if fast==nil || fast.Next ==nil { return nil } slow = slow.Next fast = fast.Next.Next if slow == fast { break } } for head != slow { head = head.Next slow = slow.Next } return head }  Python:
class Solution: def detectCycle(self, head: ListNode) -&amp;gt; ListNode: slow, fast = head, head while True: if fast == None or fast.</description>
    </item>
    
    <item>
      <title>84.Largest Rectangle in Histogram</title>
      <link>https://blog.arboat.top/posts/leetcode-84.largest-rectangle-in-histogram/</link>
      <pubDate>Thu, 21 May 2020 00:05:00 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-84.largest-rectangle-in-histogram/</guid>
      <description>暴力法  时间复杂度 O(n^2) 空间复杂度 O(1)  遍历所有高度， 以高度求最大矩形
单调栈 用栈以空间换时间  时间复杂度 O(n) 空间复杂度 O(n)  左右分别遍历
Go:
func largestRectangleArea(heights []int) int { n:=len(heights) left, right := make([]int,n), make([]int, n) stack:= make([]int,0) for i:=0;i&amp;lt;n;i++ { for len(stack) &amp;gt;0 &amp;amp;&amp;amp; heights[stack[len(stack)-1]] &amp;gt;= heights[i]{ stack = stack[:len(stack)-1] } if len(stack) == 0{ left[i] = -1 } else { left[i] = stack[len(stack)-1] } stack = append(stack,i) } stack= make([]int,0) for i:=n-1; i&amp;gt;=0; i-- { for len(stack) &amp;gt;0 &amp;amp;&amp;amp; heights[stack[len(stack)-1]] &amp;gt;= heights[i]{ stack = stack[:len(stack)-1] } if len(stack) == 0{ right[i] = n } else { right[i] = stack[len(stack)-1] } stack = append(stack,i) } result:=0 for i:=0;i&amp;lt;n;i++ { result = max(result,(right[i]-left[i]-1)*heights[i]) } return result } func max(x, y int) int { if x &amp;gt; y { return x } return y }  单调栈，一遍遍历  时间复杂度 O(n) 空间复杂度 O(n)  Go：</description>
    </item>
    
    <item>
      <title>283.Move Zeroes</title>
      <link>https://blog.arboat.top/posts/leetcode-283.move-zeroes/</link>
      <pubDate>Fri, 01 May 2020 00:00:06 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-283.move-zeroes/</guid>
      <description>时间复杂度:O(n) 空间复杂度:O(1)  两次遍历： Go:
func moveZeroes(nums []int) { // if nums == nil { // return // } i,j:=0,0 for i=0;i&amp;lt;len(nums);i++{ if nums[i]!=0{ nums[j]=nums[i] j++ } } //j为第一个零位置, 遍历为0 for ;j&amp;lt;len(nums);j++{ nums[j]=0 } }  Python:
class Solution: def moveZeroes(self, nums: List[int]) -&amp;gt; None: &amp;quot;&amp;quot;&amp;quot; Do not return anything, modify nums in-place instead. &amp;quot;&amp;quot;&amp;quot; i,j=0,0 while i&amp;lt;len(nums): if nums[i] != 0: nums[j]=nums[i] j+=1 i+=1 while j&amp;lt; len(nums): nums[j]=0 j+=1  双指针一次遍历 复制到第一个零的位置，并置零  时间复杂度:O(n) 空间复杂度:O(1)  Go:</description>
    </item>
    
    <item>
      <title>66.Plus One</title>
      <link>https://blog.arboat.top/posts/leetcode-66.plus-one/</link>
      <pubDate>Fri, 01 May 2020 00:00:06 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-66.plus-one/</guid>
      <description> 时间复杂度:O(n) 空间复杂度:O(1)  转数字+1再转成数组 迭代： Go:
// 判断最后位是不是9，不是直接加一返回，是的话加向前遍历； // 遍历正常推出，那么 第一位加一个1 func plusOne(digits []int) []int { for i:=len(digits)-1;i&amp;gt;=0;i--{ //注意最后一个index if digits[i]!=9{ digits[i]++ return digits } else { digits[i]=0 } } return append([]int{1},digits...) }  Python:
class Solution(object): def plusOne(self, digits): &amp;quot;&amp;quot;&amp;quot; :type digits: List[int] :rtype: List[int] &amp;quot;&amp;quot;&amp;quot; i=len(digits)-1 while i&amp;gt;=0: if digits[i]!=9: digits[i]+=1 return digits else: digits[i]=0 i-=1 digits.insert(0, 1) return digits  </description>
    </item>
    
    <item>
      <title>169.Majority Element</title>
      <link>https://blog.arboat.top/posts/leetcode-169.majority-element/</link>
      <pubDate>Fri, 01 May 2020 00:00:03 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-169.majority-element/</guid>
      <description>排序取中位数:
 时间复杂度：O((nlogn) 空间复杂度：O(logn)  Go:
func majorityElement(nums []int) int { sort.Ints(nums) return nums[len(nums)/2] }  分治:
 时间复杂度：O((nlogn) 空间复杂度：O(logn)  func majorityElement(nums []int) int { return record(nums,0,len(nums)-1)
}
func countInSlice(nums []int, num, low, high int) int { count:=0 for i:=low;i&amp;lt;=high;i++{ if nums[i] == num { count++ } } return count } func record(nums []int, low, high int) int { if low == high { return nums[low] } mid:=(high-low)/2 + low left:=record(nums,low,mid) right:=record(nums,mid+1,high) if left == right { return left } leftCount:=countInSlice(nums,left,low,high) rightCount:=countInSlice(nums,right,low,high) if leftCount &amp;gt; rightCount { return left } return right }</description>
    </item>
    
    <item>
      <title>17.Letter Combinations of a Phone Number</title>
      <link>https://blog.arboat.top/posts/leetcode-17.letter-combinations-of-a-phone-number/</link>
      <pubDate>Fri, 01 May 2020 00:00:03 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-17.letter-combinations-of-a-phone-number/</guid>
      <description>递归:
 m 是输入中对应 3 个字母的数字个数，n 是输入中对应 4 个字母的数字个数 时间复杂度：O((3^m+4^n) 空间复杂度：O(m+n)  Go:
var phoneMap = map[string]string { &amp;quot;2&amp;quot;: &amp;quot;abc&amp;quot;, &amp;quot;3&amp;quot;: &amp;quot;def&amp;quot;, &amp;quot;4&amp;quot;: &amp;quot;ghi&amp;quot;, &amp;quot;5&amp;quot;: &amp;quot;jkl&amp;quot;, &amp;quot;6&amp;quot;: &amp;quot;mno&amp;quot;, &amp;quot;7&amp;quot;: &amp;quot;pqrs&amp;quot;, &amp;quot;8&amp;quot;: &amp;quot;tuv&amp;quot;, &amp;quot;9&amp;quot;: &amp;quot;wxyz&amp;quot;, } func letterCombinations(digits string) []string { res :=[]string{} // 特殊情况 if len(digits) == 0 { return res } var backTrack func(path string, cur int) backTrack = func(path string, cur int) { if cur == len(digits) { res = append(res,path) return } // string index 的值要在string digit:=string(digits[cur]) letters:=phoneMap[digit] for _,v:=range letters{ path = path + string(v) backTrack(path,cur+1) path = path[:len(path)-1] } } backTrack(&amp;quot;&amp;quot;,0) return res }  </description>
    </item>
    
    <item>
      <title>46.Permutations</title>
      <link>https://blog.arboat.top/posts/leetcode-46.permutations/</link>
      <pubDate>Fri, 01 May 2020 00:00:03 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-46.permutations/</guid>
      <description>递归:
 时间复杂度：O((n*n!) 空间复杂度：O(n*n!)  Go:
func permute(nums []int) [][]int { res := [][]int{} item := []int{} used := make([]bool,len(nums)) var backtrack func([]int,[]int,[]bool) backtrack = func(item, nums[]int, used[]bool){ if len(item) == len(nums) { tmp:= make([]int,len(item)) copy(tmp,item) res = append(res,tmp) } for i,v:=range nums { if !used[i]{ //yes used[i] = true item = append(item,v) //back backtrack(item,nums,used) //no item = item[:len(item)-1] used[i] = false } } } backtrack(item,nums,used) return res } </description>
    </item>
    
    <item>
      <title>47.Permutations II</title>
      <link>https://blog.arboat.top/posts/leetcode-47.permutations-ii/</link>
      <pubDate>Fri, 01 May 2020 00:00:03 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-47.permutations-ii/</guid>
      <description>递归:
 时间复杂度：O((n*n!) 空间复杂度：O(n*n!)  Go:
func permuteUnique(nums []int) [][]int { res := [][]int{} item := []int{} used := make([]bool,len(nums)) sort.Ints(nums) var backtrack func([]int,[]int,[]bool) backtrack = func(item, nums[]int, used[]bool){ if len(item) == len(nums) { tmp:= make([]int,len(item)) copy(tmp,item) res = append(res,tmp) } for i,v:=range nums { if !used[i]{ //剪枝 !更彻底，顺序 if i&amp;gt;0 &amp;amp;&amp;amp; v == nums[i-1] &amp;amp;&amp;amp; !used[i-1] { //if i&amp;gt;0 &amp;amp;&amp;amp; v == nums[i-1] &amp;amp;&amp;amp; used[i-1] { continue } //yes used[i] = true item = append(item,v) //back backtrack(item,nums,used) //no item = item[:len(item)-1] used[i] = false } } } backtrack(item,nums,used) return res } </description>
    </item>
    
    <item>
      <title>50.Pow(x, n)</title>
      <link>https://blog.arboat.top/posts/leetcode-50.powx-n/</link>
      <pubDate>Fri, 01 May 2020 00:00:03 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-50.powx-n/</guid>
      <description>递归:
 时间复杂度O(logn) 空间复杂度O(logn)  Go:
func myPow(x float64, n int) float64 { if n &amp;gt;= 0 { return dealer(x,n) } return 1.0/dealer(x,-n) } func dealer(x float64, n int) float64 { if n == 0 { return 1 } temp := dealer(x,n/2) if n%2 == 0 { return temp*temp } return temp * temp * x }  迭代
 时间复杂度O(logn) 空间复杂度O(1)  Go:
func myPow(x float64, n int) float64 { if n &amp;gt;= 0 { return dealer(x,n) } return 1.</description>
    </item>
    
    <item>
      <title>51.N-Queens</title>
      <link>https://blog.arboat.top/posts/leetcode-51.n-queens/</link>
      <pubDate>Fri, 01 May 2020 00:00:03 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-51.n-queens/</guid>
      <description>递归:
 时间复杂度O(N!) 空间复杂度O(N)  Go:
func solveNQueens(n int) [][]string { res:=[][]string{} queens:=make([]int,n) for i:=range queens { queens[i] = -1 } c,d1,d2:=map[int]bool{},map[int]bool{},map[int]bool{} var backTrack func(queens[]int,row int,c,d1,d2 map[int]bool) backTrack = func(queens[]int,row int,c,d1,d2 map[int]bool){ if row == n{ solution:=generate(queens,n) res = append(res,solution) return } for i:=0;i&amp;lt;n;i++{ if c[i] || d1[row-i] || d2[row+i] { continue } queens[row]=i c[i], d1[row-i], d2[row+i] = true, true, true backTrack(queens,row+1,c,d1,d2) queens[row]=-1 delete(c,i) delete(d1,row-i) delete(d2,row+i) } } backTrack(queens,0,c,d1,d2) return res } func generate(queens[]int, n int) []string { solution:=[]string{} for i:=0;i&amp;lt;n;i++{ row:=make([]byte,n) for j:=0;j&amp;lt;n;j++{ row[j]=&#39;.</description>
    </item>
    
    <item>
      <title>70.Climbing Stairs</title>
      <link>https://blog.arboat.top/posts/leetcode-70.climbing-stairs/</link>
      <pubDate>Fri, 01 May 2020 00:00:03 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-70.climbing-stairs/</guid>
      <description>分析可得本题为Fibonacci sequence
用通项公式：
 时间复杂度：O(log n) 空间复杂度：O(1)  用动态规划（滑动数组):
 时间复杂度：O(n) 空间复杂度：O(1)  Go:
func climbStairs(n int) int { p,q,r:=1,1,1 for i:=2 ; i&amp;lt;=n ;i++ { p = q q = r r = p + q } return r }  Python:
class Solution: def climbStairs(self, n: int) -&amp;gt; int: p,q,r=1,1,1 i = 2 while i&amp;lt;=n: p=q q=r r=p+q i+=1 return r </description>
    </item>
    
    <item>
      <title>77.Combinations</title>
      <link>https://blog.arboat.top/posts/leetcode-77.combinations/</link>
      <pubDate>Fri, 01 May 2020 00:00:03 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-77.combinations/</guid>
      <description>递归:
 时间复杂度：O(( k n)×k) 空间复杂度：O(n)  Go:
func combine(n int, k int) [][]int { res:= [][]int{} item:= []int{} var dfs func(int) dfs = func(cur int) { if len(item) + (n-cur+1) &amp;lt; k { return } //copy不会影响原slice if len(item) == k { temp:=make([]int,k) copy(temp,item) res = append(res, temp) return } // yes 回溯 item = append(item, cur) dfs(cur+1) item = item[:len(item)-1] // no dfs(cur+1) } dfs(1) return res }  回溯法 注意剪枝</description>
    </item>
    
    <item>
      <title>78.Subsets</title>
      <link>https://blog.arboat.top/posts/leetcode-78.subsets/</link>
      <pubDate>Fri, 01 May 2020 00:00:03 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-78.subsets/</guid>
      <description>递归:
 时间复杂度：O((N*2^N) 空间复杂度：O(N*2^N)  Go:
func combine(n int, k int) [][]int { res:= [][]int{} item:= []int{} var dfs func(int) dfs = func(cur int) { if len(item) + (n-cur+1) &amp;lt; k { return } //copy不会影响原slice if len(item) == k { temp:=make([]int,k) copy(temp,item) res = append(res, temp) return } // yes 回溯 item = append(item, cur) dfs(cur+1) item = item[:len(item)-1] // no dfs(cur+1) } dfs(1) return res }  回溯法 注意剪枝</description>
    </item>
    
    <item>
      <title>11.ContainerWIthMostWater</title>
      <link>https://blog.arboat.top/posts/leetcode-11.containerwithmostwater/</link>
      <pubDate>Fri, 01 May 2020 00:00:01 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-11.containerwithmostwater/</guid>
      <description>暴力法  时间复杂度 O(N^2) 空间复杂度 O(1)  Go:
 func maxArea(height []int) int { max:=0 for i:=0;i&amp;lt;len(height)-1;i++{ for j:=i+1;j&amp;lt;len(height);j++{ area:= (j-i)*int(math.Min(float64(height[i]),float64(height[j]))) max=int(math.Max(float64(area),float64(max))) } } return max }  python:
class Solution: def maxArea(self, height: List[int]) -&amp;gt; int: a = 0 for i in range(len(height)-1): for j in range(i+1,len(height)): area = (j-i) * min(height[i],height[j]) a = max(a,area) return a  双指针 两侧向中间逼近，每次移动小的 时间复杂度 O(N) 空间复杂度 O(1)
Go: go 中math.Max,Min,Abs 都是float64， int要自己写</description>
    </item>
    
    <item>
      <title>1.Two Sum</title>
      <link>https://blog.arboat.top/posts/leetcode-1.two-sum.md/</link>
      <pubDate>Fri, 01 May 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-1.two-sum.md/</guid>
      <description>暴力法  时间复杂度：O(n^2) 空间复杂度：O(1)  Go:
func twoSum(nums []int, target int) []int { for i:=0;i&amp;lt;len(nums)-1;i++{ for j:=i+1;j&amp;lt;len(nums);j++{ if nums[j]+nums[i]==target { return []int{i,j} } } } }  哈希表  时间复杂度：O(n) 空间复杂度：O(n)  Go：
func twoSum(nums []int, target int) []int { m:=make(map[int]int) // nums 的v作为map的k，k作为map的v for k1,v1 := range nums { v2:=target - v1 if _,ok := m[v2]; ok { return []int{m[v2],k1} //已存在的是已经先存入map的，所以在前 } m[v1] = k1 } return nil }  Python:</description>
    </item>
    
    <item>
      <title>15.Three Sum</title>
      <link>https://blog.arboat.top/posts/leetcode-15.three-sum.md/</link>
      <pubDate>Fri, 01 May 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-15.three-sum.md/</guid>
      <description>暴力法  时间复杂度：O(n^3) 空间复杂度：O(n)  Go：
func threeSum(nums []int) [][]int { r:=make([][]int, 0) for i:=0 ; i &amp;lt; len(nums)-2 ; i++ { for j:=i+1; j&amp;lt;len(nums)-1; j++ { for k:= j+1; k&amp;lt;len(nums);k++ { if nums[i]+nums[j]+nums[k]=0 { r = append(r, []int{nums[i],nums[j],nums[j]}) } } } } return r }  Python:
def threeSum(self, nums: List[int]) -&amp;gt; List[List[int]]: res = [] for i in range(0,len(nums)-2): for j in range(i+1,len(nums)-1): for k in range(j+1,len(nums)): if nums[i]+nums[j]+nums[k] = 0: res.</description>
    </item>
    
    <item>
      <title>189. Rotate Array</title>
      <link>https://blog.arboat.top/posts/leetcode-189.-rotate-array/</link>
      <pubDate>Fri, 01 May 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-189.-rotate-array/</guid>
      <description>暴力法 时间复杂度O(n*k),空间负载度O(1)
额外数组法 下标为 i 的我们把它放到 (i+k)%数组长度 的位置。然后把新的数组拷贝到原数组中。
时空间复杂福 O（n）
3次反转法  时间复杂度： O(n) 空间复杂度：O(1)  Go:
func rotate(nums []int, k int) { k%=len(nums) reverse(nums,0,len(nums)-1) reverse(nums,0,k-1) reverse(nums,k,len(nums)-1) } func reverse(nums[]int,start,end int){ for start &amp;lt; end { temp:= nums[start] nums[start]=nums[end] nums[end]=temp start++ end-- } }  Python:
class Solution(object): def rotate(self, nums, k): &amp;quot;&amp;quot;&amp;quot; :type nums: List[int] :type k: int :rtype: None Do not return anything, modify nums in-place instead. &amp;quot;&amp;quot;&amp;quot; k%=len(nums) self.</description>
    </item>
    
    <item>
      <title>242.Valid Anagram</title>
      <link>https://blog.arboat.top/posts/leetcode-242.valid-anagram/</link>
      <pubDate>Fri, 01 May 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-242.valid-anagram/</guid>
      <description>question: 1.大小写 2.完全相同
先分别排序，再比较  时间复杂度 O(nlogn) 空间复杂度 O(1)  Go:
func isAnagram(s string, t string) bool { sByte:=[]byte(s) tByte:=[]byte(t) if len(sByte) != len(tByte){ return false } sort.Slice(sByte,func(i,j int) bool { return sByte[i]&amp;lt;sByte[j] }) sort.Slice(tByte,func(i,j int) bool { return tByte[i]&amp;lt;tByte[j] }) for i,v:=range sByte{ if v!=tByte[i] { return false } } return true }  Python:
class Solution: def isAnagram(self, s: str, t: str) -&amp;gt; bool: return sorted(s) == sorted(t)  哈希表  时间复杂度 O(n) 空间复杂度 O(1)  Go:</description>
    </item>
    
    <item>
      <title>26. Remove Duplicates from Sorted Array</title>
      <link>https://blog.arboat.top/posts/leetcode-26.-remove-duplicates-from-sorted-array/</link>
      <pubDate>Fri, 01 May 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-26.-remove-duplicates-from-sorted-array/</guid>
      <description>双指针  时间复杂度：O(n) 空间复杂度：O(1)  Go：
func removeDuplicates(nums []int) int { if len(nums) == 0 { return 0 } i,j:=0,1 for ;j&amp;lt;len(nums);j++{ if nums[i]!=nums[j]{ i++ nums[i]=nums[j] } } return i+1 }  Python:
class Solution: def removeDuplicates(self, nums: List[int]) -&amp;gt; int: if len(nums) == 0: return 0 i=0 for j in range(1,len(nums)): if nums[i]!=nums[j]: i+=1 nums[i]=nums[j] return i+1  </description>
    </item>
    
    <item>
      <title>49.Group Anagrams</title>
      <link>https://blog.arboat.top/posts/leetcode-49.group-anagrams/</link>
      <pubDate>Fri, 01 May 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-49.group-anagrams/</guid>
      <description>question: 1.大小写 2.完全相同
先计算每个字符串中数字次数的数组，再存入map，返回map value的数组  时间复杂度 O(nk),其中 NN 是 strs 的长度，而 KK 是 strs 中字符串的最大长度。计算每个字符串的字符串大小是线性的，我们统计每个字符串 空间复杂度 O(nk),排序存储在 res 中的全部信息内容  Go:
func groupAnagrams(strs []string) [][]string { m:=make(map[[26]int][]string) for _,v:=range strs{ k:=strKey(v) s,ok:=m[k] if ok { s=append(s,v) // s为copy 需要重新赋值 m[k]=s } else { m[k]=[]string{v} } } res:=make([][]string,0) for _,v:=range m{ res = append(res,v) } return res } func strKey(s string)[26]int{ res:=[26]int{} for _,v:=range s{ res[v-&#39;a&#39;]++ //单引号 表示rune 只能一个字符int32 } return res } </description>
    </item>
    
    <item>
      <title>88.Merge Sorted Array</title>
      <link>https://blog.arboat.top/posts/leetcode-88.merge-sorted-array/</link>
      <pubDate>Fri, 01 May 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.arboat.top/posts/leetcode-88.merge-sorted-array/</guid>
      <description>合并后排序  时间复杂度 : O((n+m)log(n+m))。 空间复杂度 : O(1)。  双指针：从前往后：  时间复杂度 : O(n+m)。 空间复杂度 : O(m)。  双指针：从后往前：  时间复杂度 : O(n+m)。 空间复杂度 : O(1)。  Go:
func merge(nums1 []int, m int, nums2 []int, n int) { p, p1, p2:= m+n-1,m-1,n-1 for p1&amp;gt;=0 &amp;amp;&amp;amp; p2&amp;gt;=0 { if nums1[p1]&amp;gt;nums2[p2]{ nums1[p]=nums1[p1] p1-- } else { nums1[p]=nums2[p2] p2-- } p-- } if p1&amp;lt;0 { // nums1[:p2+1]=nums2[:p2+1] cannot assign to nums1[:p2 + 1] 右值 for i:=0;i&amp;lt;p2+1;i++{ nums1[i]=nums2[i] } } }  Python:</description>
    </item>
    
  </channel>
</rss>