<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ArBlog</title>
    <link>http://example.org/</link>
    <description>Recent content on ArBlog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 21 Jul 2020 00:00:00 -0006</lastBuildDate>
    
        <atom:link href="http://example.org/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>283.Move Zeroes</title>
        <link>http://example.org/posts/leetcode-283.move-zeroes/</link>
        <pubDate>Tue, 21 Jul 2020 00:00:00 -0006</pubDate>
        
        <guid>http://example.org/posts/leetcode-283.move-zeroes/</guid>
        <description>ArBlog http://example.org/posts/leetcode-283.move-zeroes/ -&lt;h1 id=&#34;双指针-复制到第一个零的位置并置零&#34;&gt;双指针 复制到第一个零的位置，并置零&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度:O(n)&lt;/li&gt;
&lt;li&gt;空间复杂度:O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Go:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func moveZeroes(nums []int)  {
    j:=0 //第一个非零前位置
    for i:=0;i&amp;lt;len(nums);i++ {
        if nums[i] != 0 {
            nums[j] = nums[i]
            if i != j {
                nums[i] = 0
            }
            j++
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Python:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution(object):
    def moveZeroes(self, nums):
        &amp;quot;&amp;quot;&amp;quot;
        :type nums: List[int]
        :rtype: None Do not return anything, modify nums in-place instead.
        &amp;quot;&amp;quot;&amp;quot;
        j = 0
        for i in range(len(nums)):
            if nums[i] != 0:
                nums[j] = nums[i]
                if i != j:
                    nums[i] = 0
                j+=1&lt;/code&gt;&lt;/pre&gt;
- http://example.org/posts/leetcode-283.move-zeroes/ - </description>
        </item>
    
    
    
        <item>
        <title>206.Reverse Linked List</title>
        <link>http://example.org/posts/leetcode-206.reverse-linked-list/</link>
        <pubDate>Tue, 21 Jul 2020 00:00:00 -0005</pubDate>
        
        <guid>http://example.org/posts/leetcode-206.reverse-linked-list/</guid>
        <description>ArBlog http://example.org/posts/leetcode-206.reverse-linked-list/ -&lt;pre&gt;&lt;code&gt;/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;iteratively&#34;&gt;iteratively&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;func reverseList(head *ListNode) *ListNode {
    var pre *ListNode
    for head != nil {
        head, pre, head.Next = head.Next, head, pre
    }
    // for head != nil {
    //  	temp:=head.Next
    //  	head.Next = pre
    //  	pre = head
    //  	head = temp
    //}
    return pre
}
时间复杂度：O(n)，假设 n 是列表的长度，时间复杂度是 O(n)。
空间复杂度：O(1)。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;recursively&#34;&gt;recursively&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;func reverseList(head *ListNode) *ListNode {
if head == nil || head.Next == nil {
    return head
}
pre:=reverseList(head.Next)
head.Next.Next = head
head.Next = nil
return pre
}
时间复杂度：O(n)，假设 n 是列表的长度，那么时间复杂度为 O(n)。
空间复杂度：O(n)，由于使用递归，将会使用隐式栈空间。递归深度可能会达到 n 层。
&lt;/code&gt;&lt;/pre&gt;
- http://example.org/posts/leetcode-206.reverse-linked-list/ - </description>
        </item>
    
    
    
        <item>
        <title>92.Reverse Linked List II (part)</title>
        <link>http://example.org/posts/leetcode-92.reverse-linked-list-ii-part/</link>
        <pubDate>Tue, 21 Jul 2020 00:00:00 -0004</pubDate>
        
        <guid>http://example.org/posts/leetcode-92.reverse-linked-list-ii-part/</guid>
        <description>ArBlog http://example.org/posts/leetcode-92.reverse-linked-list-ii-part/ -&lt;h1 id=&#34;recursively&#34;&gt;recursively&lt;/h1&gt;
&lt;h2 id=&#34;反转链表前-n-个节点&#34;&gt;反转链表前 N 个节点&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt; func reverseList(head *ListNode, n int) *ListNode {
    var successor *ListNode
    if n == 1 {
        successor = head.next
        return head
    }
    pre:=reverseList(head.Next,n-1)
    head.Next.Next = head
    head.Next = successor
    return pre
    }
    时间复杂度：O(n)，假设 n 是列表的长度，那么时间复杂度为 O(n)。
    空间复杂度：O(n)，由于使用递归，将会使用隐式栈空间。递归深度可能会达到 n 层。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;reverse-a-linked-list-from-position-m-to-n&#34;&gt;Reverse a linked list from position m to n&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseBetween(head *ListNode, m int, n int) *ListNode {
    if m == 1 {
        return reverseN(head, n)
    }
    head.Next = reverseBetween(head.Next, m-1 ,n-1)
    return head
}

var follower *ListNode

func reverseN(head *ListNode ,n int) *ListNode {
    if n == 1 {
        follower = head.Next
        return head
    }
    prev := reverseN(head.Next, n-1)
    head.Next.Next = head
    head.Next = follower
    return prev
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;头插法&#34;&gt;头插法&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseBetween(head *ListNode, m int, n int) *ListNode {
    dummy := &amp;amp;ListNode{Next:head}
    g:= dummy
    p:=dummy.Next
    
    step:=0
    for step + 1 &amp;lt; m {
        g=g.Next
        p=p.Next
        step++
    }
    for i:=0 ; i&amp;lt; n-m ;i++ {
        temp := p.Next
        p.Next = p.Next.Next
        temp.Next = g.Next    // 注意p第二次之后不是g.Next，只有第一次是
        g.Next = temp         // linked List 画图
    }
    return dummy.Next
}&lt;/code&gt;&lt;/pre&gt;
- http://example.org/posts/leetcode-92.reverse-linked-list-ii-part/ - </description>
        </item>
    
    
    
        <item>
        <title>70.Climbing Stairs</title>
        <link>http://example.org/posts/leetcode-70.climbing-stairs/</link>
        <pubDate>Tue, 21 Jul 2020 00:00:00 -0003</pubDate>
        
        <guid>http://example.org/posts/leetcode-70.climbing-stairs/</guid>
        <description>ArBlog http://example.org/posts/leetcode-70.climbing-stairs/ -&lt;p&gt;分析可得本题为Fibonacci sequence&lt;/p&gt;
&lt;p&gt;用通项公式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(log n)&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用动态规划（滑动数组):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n)&lt;/li&gt;
&lt;li&gt;空间复杂度：O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Go:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func climbStairs(n int) int {
    p,q,r:=1,1,1
    for i:=2 ; i&amp;lt;=n ;i++ {
        p = q
        q = r
        r = p + q
    }
    return r
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Python:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution:
    def climbStairs(self, n: int) -&amp;gt; int:
        p,q,r=1,1,1
        i = 2 
        while i&amp;lt;=n:
            p=q
            q=r
            r=p+q
            i+=1
        return r&lt;/code&gt;&lt;/pre&gt;
- http://example.org/posts/leetcode-70.climbing-stairs/ - </description>
        </item>
    
    
    
        <item>
        <title>11.ContainerWIthMostWater</title>
        <link>http://example.org/posts/leetcode-11.containerwithmostwater/</link>
        <pubDate>Tue, 21 Jul 2020 00:00:00 -0001</pubDate>
        
        <guid>http://example.org/posts/leetcode-11.containerwithmostwater/</guid>
        <description>ArBlog http://example.org/posts/leetcode-11.containerwithmostwater/ -&lt;h2 id=&#34;暴力法&#34;&gt;暴力法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度 O(N^2)&lt;/li&gt;
&lt;li&gt;空间复杂度 O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Go:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    func maxArea(height []int) int {
      max:=0
      for i:=0;i&amp;lt;len(height)-1;i++{
        for j:=i+1;j&amp;lt;len(height);j++{
          area:= (j-i)*int(math.Min(float64(height[i]),float64(height[j])))
          max=int(math.Max(float64(area),float64(max)))
        }
      }
      return max
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;python:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution:
    def maxArea(self, height: List[int]) -&amp;gt; int:
        a = 0
        for i in range(len(height)-1):
            for j in range(i,len(height)):
                area = (j-i) * min(height[i],height[j])
                a = max(a,area)
        return a
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;双指针&#34;&gt;双指针&lt;/h2&gt;
&lt;p&gt;两侧向中间逼近，每次移动小的
时间复杂度 O(N)
空间复杂度 O(1)&lt;/p&gt;
&lt;p&gt;Go:
go 中math.Max,Min,Abs 都是float64， int要自己写&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func maxArea(height []int) int {
    max:=0
    i,j:=0,len(height)-1
    for i!=j {
        area:= (j-i)*min(height[i],height[j])
        if area &amp;gt; max {
            max = area
        }
        if height[i] &amp;gt; height[j] {
            j--
        } else {
            i++
        }
    }
    return max
}

func min(a,b int) int {
    if a &amp;gt;= b {
        return b
    } else {
        return a
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;python：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution:
    def maxArea(self, height: List[int]) -&amp;gt; int:
        m = 0
        i, j= 0, len(height)-1
        while i!=j:
            area=(j-i)*min(height[i],height[j])
            m=max(area,m)
            if height[i] &amp;gt; height[j]:
                j-=1
            else:
                i+=1
        return m
&lt;/code&gt;&lt;/pre&gt;
- http://example.org/posts/leetcode-11.containerwithmostwater/ - </description>
        </item>
    
    
    
        <item>
        <title>1.Two Sum</title>
        <link>http://example.org/posts/leetcode-1.two-sum.md/</link>
        <pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate>
        
        <guid>http://example.org/posts/leetcode-1.two-sum.md/</guid>
        <description>ArBlog http://example.org/posts/leetcode-1.two-sum.md/ -&lt;h1 id=&#34;哈希表&#34;&gt;哈希表&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：O(n)&lt;/li&gt;
&lt;li&gt;空间复杂度：O(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Go：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func twoSum(nums []int, target int) []int {
    m:=make(map[int]int)          // nums 的v作为map的k，k作为map的v
    for k1,v1 := range nums {
        v2:=target - v1
        if _,ok := m[v2]; ok {
            return []int{m[v2],k1}  //已存在的是已经先存入map的，所以在前
        }
        m[v1] = k1
    }
    return nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Python:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution(object):
    def twoSum(self, nums, target):
        &amp;quot;&amp;quot;&amp;quot;
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        &amp;quot;&amp;quot;&amp;quot;
        dic = {}
        for k1,v1 in enumerate(nums):  // k,v 遍历
            v2 = target - v1
            if v2 in dic:
                return [dic[v2],k1]
            dic[v1]=k1
        return {}&lt;/code&gt;&lt;/pre&gt;
- http://example.org/posts/leetcode-1.two-sum.md/ - </description>
        </item>
    
    
  </channel>
</rss> 