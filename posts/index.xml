<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on ArBlog</title>
    <link>https://arboat.github.io/posts/</link>
    <description>Recent content in Posts on ArBlog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://arboat.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
  </channel>
</rss>="self" type="application/rss+xml" />
    
    
    <item>
      <title>206.Reverse Linked List</title>
      <link>https://arboat.github.io/posts/leetcode-206.reverse-linked-list/</link>
      <pubDate>Tue, 21 Jul 2020 00:05:00 +0800</pubDate>
      
      <guid>https://arboat.github.io/posts/leetcode-206.reverse-linked-list/</guid>
      <description>/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */  iteratively func reverseList(head *ListNode) *ListNode { var pre *ListNode for head != nil { head, pre, head.Next = head.Next, head, pre } // for head != nil { // temp:=head.Next // head.Next = pre // pre = head // head = temp //} return pre } 时间复杂度：O(n)，假设 n 是列表的长度，时间复杂度是 O(n)。 空间复杂度：O(1)。  recursively func reverseList(head *ListNode) *ListNode { if head == nil || head.</description>
    </item>
    
    <item>
      <title>283.Move Zeroes</title>
      <link>https://arboat.github.io/posts/leetcode-283.move-zeroes/</link>
      <pubDate>Tue, 21 Jul 2020 00:00:06 +0800</pubDate>
      
      <guid>https://arboat.github.io/posts/leetcode-283.move-zeroes/</guid>
      <description>双指针 复制到第一个零的位置，并置零  时间复杂度:O(n) 空间复杂度:O(1)  Go:
func moveZeroes(nums []int) { j:=0 //第一个非零前位置 for i:=0;i&amp;lt;len(nums);i++ { if nums[i] != 0 { nums[j] = nums[i] if i != j { nums[i] = 0 } j++ } } }  Python:
class Solution(object): def moveZeroes(self, nums): &amp;quot;&amp;quot;&amp;quot; :type nums: List[int] :rtype: None Do not return anything, modify nums in-place instead. &amp;quot;&amp;quot;&amp;quot; j = 0 for i in range(len(nums)): if nums[i] != 0: nums[j] = nums[i] if i !</description>
    </item>
    
    <item>
      <title>92.Reverse Linked List II (part)</title>
      <link>https://arboat.github.io/posts/leetcode-92.reverse-linked-list-ii-part/</link>
      <pubDate>Tue, 21 Jul 2020 00:00:04 +0800</pubDate>
      
      <guid>https://arboat.github.io/posts/leetcode-92.reverse-linked-list-ii-part/</guid>
      <description>recursively 反转链表前 N 个节点  func reverseList(head *ListNode, n int) *ListNode { var successor *ListNode if n == 1 { successor = head.next return head } pre:=reverseList(head.Next,n-1) head.Next.Next = head head.Next = successor return pre } 时间复杂度：O(n)，假设 n 是列表的长度，那么时间复杂度为 O(n)。 空间复杂度：O(n)，由于使用递归，将会使用隐式栈空间。递归深度可能会达到 n 层。  Reverse a linked list from position m to n /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseBetween(head *ListNode, m int, n int) *ListNode { if m == 1 { return reverseN(head, n) } head.</description>
    </item>
    
    <item>
      <title>70.Climbing Stairs</title>
      <link>https://arboat.github.io/posts/leetcode-70.climbing-stairs/</link>
      <pubDate>Tue, 21 Jul 2020 00:00:03 +0800</pubDate>
      
      <guid>https://arboat.github.io/posts/leetcode-70.climbing-stairs/</guid>
      <description>分析可得本题为Fibonacci sequence
用通项公式：
 时间复杂度：O(log n) 空间复杂度：O(1)  用动态规划（滑动数组):
 时间复杂度：O(n) 空间复杂度：O(1)  Go:
func climbStairs(n int) int { p,q,r:=1,1,1 for i:=2 ; i&amp;lt;=n ;i++ { p = q q = r r = p + q } return r }  Python:
class Solution: def climbStairs(self, n: int) -&amp;gt; int: p,q,r=1,1,1 i = 2 while i&amp;lt;=n: p=q q=r r=p+q i+=1 return r </description>
    </item>
    
    <item>
      <title>11.ContainerWIthMostWater</title>
      <link>https://arboat.github.io/posts/leetcode-11.containerwithmostwater/</link>
      <pubDate>Tue, 21 Jul 2020 00:00:01 +0800</pubDate>
      
      <guid>https://arboat.github.io/posts/leetcode-11.containerwithmostwater/</guid>
      <description>暴力法  时间复杂度 O(N^2) 空间复杂度 O(1)  Go:
 func maxArea(height []int) int { max:=0 for i:=0;i&amp;lt;len(height)-1;i++{ for j:=i+1;j&amp;lt;len(height);j++{ area:= (j-i)*int(math.Min(float64(height[i]),float64(height[j]))) max=int(math.Max(float64(area),float64(max))) } } return max }  python:
class Solution: def maxArea(self, height: List[int]) -&amp;gt; int: a = 0 for i in range(len(height)-1): for j in range(i,len(height)): area = (j-i) * min(height[i],height[j]) a = max(a,area) return a  双指针 两侧向中间逼近，每次移动小的 时间复杂度 O(N) 空间复杂度 O(1)
Go: go 中math.Max,Min,Abs 都是float64， int要自己写</description>
    </item>
    
    <item>
      <title>1.Two Sum</title>
      <link>https://arboat.github.io/posts/leetcode-1.two-sum.md/</link>
      <pubDate>Tue, 21 Jul 2020 00:00:00 +0800</pubDate>
      
      <guid>https://arboat.github.io/posts/leetcode-1.two-sum.md/</guid>
      <description>哈希表  时间复杂度：O(n) 空间复杂度：O(n)  Go：
func twoSum(nums []int, target int) []int { m:=make(map[int]int) // nums 的v作为map的k，k作为map的v for k1,v1 := range nums { v2:=target - v1 if _,ok := m[v2]; ok { return []int{m[v2],k1} //已存在的是已经先存入map的，所以在前 } m[v1] = k1 } return nil }  Python:
class Solution(object): def twoSum(self, nums, target): &amp;quot;&amp;quot;&amp;quot; :type nums: List[int] :type target: int :rtype: List[int] &amp;quot;&amp;quot;&amp;quot; dic = {} for k1,v1 in enumerate(nums): // k,v 遍历 v2 = target - v1 if v2 in dic: return [dic[v2],k1] dic[v1]=k1 return {} </description>
    </item>
    
  </channel>
</rss>