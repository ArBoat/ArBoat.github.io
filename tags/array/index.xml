<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>array on ArBlog</title>
    <link>https://arboat.github.io/tags/array/</link>
    <description>Recent content in array on ArBlog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 21 Jul 2020 00:00:00 -0006</lastBuildDate>
    
	<atom:link href="https://arboat.github.io/tags/array/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>283.Move Zeroes</title>
      <link>https://arboat.github.io/posts/leetcode-283.move-zeroes/</link>
      <pubDate>Tue, 21 Jul 2020 00:00:00 -0006</pubDate>
      
      <guid>https://arboat.github.io/posts/leetcode-283.move-zeroes/</guid>
      <description>双指针 复制到第一个零的位置，并置零  时间复杂度:O(n) 空间复杂度:O(1)  Go:
func moveZeroes(nums []int) { j:=0 //第一个非零前位置 for i:=0;i&amp;lt;len(nums);i++ { if nums[i] != 0 { nums[j] = nums[i] if i != j { nums[i] = 0 } j++ } } }  Python:
class Solution(object): def moveZeroes(self, nums): &amp;quot;&amp;quot;&amp;quot; :type nums: List[int] :rtype: None Do not return anything, modify nums in-place instead. &amp;quot;&amp;quot;&amp;quot; j = 0 for i in range(len(nums)): if nums[i] != 0: nums[j] = nums[i] if i !</description>
    </item>
    
    <item>
      <title>70.Climbing Stairs</title>
      <link>https://arboat.github.io/posts/leetcode-70.climbing-stairs/</link>
      <pubDate>Tue, 21 Jul 2020 00:00:00 -0003</pubDate>
      
      <guid>https://arboat.github.io/posts/leetcode-70.climbing-stairs/</guid>
      <description>分析可得本题为Fibonacci sequence
用通项公式：
 时间复杂度：O(log n) 空间复杂度：O(1)  用动态规划（滑动数组):
 时间复杂度：O(n) 空间复杂度：O(1)  Go:
func climbStairs(n int) int { p,q,r:=1,1,1 for i:=2 ; i&amp;lt;=n ;i++ { p = q q = r r = p + q } return r }  Python:
class Solution: def climbStairs(self, n: int) -&amp;gt; int: p,q,r=1,1,1 i = 2 while i&amp;lt;=n: p=q q=r r=p+q i+=1 return r </description>
    </item>
    
    <item>
      <title>11.ContainerWIthMostWater</title>
      <link>https://arboat.github.io/posts/leetcode-11.containerwithmostwater/</link>
      <pubDate>Tue, 21 Jul 2020 00:00:00 -0001</pubDate>
      
      <guid>https://arboat.github.io/posts/leetcode-11.containerwithmostwater/</guid>
      <description>暴力法  时间复杂度 O(N^2) 空间复杂度 O(1)  Go:
 func maxArea(height []int) int { max:=0 for i:=0;i&amp;lt;len(height)-1;i++{ for j:=i+1;j&amp;lt;len(height);j++{ area:= (j-i)*int(math.Min(float64(height[i]),float64(height[j]))) max=int(math.Max(float64(area),float64(max))) } } return max }  python:
class Solution: def maxArea(self, height: List[int]) -&amp;gt; int: a = 0 for i in range(len(height)-1): for j in range(i,len(height)): area = (j-i) * min(height[i],height[j]) a = max(a,area) return a  双指针 两侧向中间逼近，每次移动小的 时间复杂度 O(N) 空间复杂度 O(1)
Go: go 中math.Max,Min,Abs 都是float64， int要自己写</description>
    </item>
    
    <item>
      <title>1.Two Sum</title>
      <link>https://arboat.github.io/posts/leetcode-1.two-sum.md/</link>
      <pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://arboat.github.io/posts/leetcode-1.two-sum.md/</guid>
      <description>哈希表  时间复杂度：O(n) 空间复杂度：O(n)  Go：
func twoSum(nums []int, target int) []int { m:=make(map[int]int) // nums 的v作为map的k，k作为map的v for k1,v1 := range nums { v2:=target - v1 if _,ok := m[v2]; ok { return []int{m[v2],k1} //已存在的是已经先存入map的，所以在前 } m[v1] = k1 } return nil }  Python:
class Solution(object): def twoSum(self, nums, target): &amp;quot;&amp;quot;&amp;quot; :type nums: List[int] :type target: int :rtype: List[int] &amp;quot;&amp;quot;&amp;quot; dic = {} for k1,v1 in enumerate(nums): // k,v 遍历 v2 = target - v1 if v2 in dic: return [dic[v2],k1] dic[v1]=k1 return {} </description>
    </item>
    
  </channel>
</rss>